<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>2026 Reading Tracker</title>
    <link href="https://fonts.googleapis.com/css2?family=Crimson+Pro:wght@300;400;600;700&family=Libre+Baskerville:wght@400;700&family=IBM+Plex+Sans:wght@300;400;500;600&display=swap" rel="stylesheet">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        :root {
            --cream: #FBF8F3;
            --dark-brown: #2C2416;
            --medium-brown: #5C4A33;
            --warm-beige: #E8DFD0;
            --accent-terracotta: #C1734F;
            --accent-sage: #7A8F6C;
            --accent-burgundy: #8B3A3A;
            --light-gold: #D4AF6A;
        }

        body {
            font-family: 'IBM Plex Sans', sans-serif;
            background: var(--cream);
            color: var(--dark-brown);
            line-height: 1.6;
            padding: 0;
            min-height: 100vh;
        }

        .header {
            background: linear-gradient(135deg, var(--dark-brown) 0%, var(--medium-brown) 100%);
            color: var(--cream);
            padding: 3rem 2rem 2rem;
            text-align: center;
            border-bottom: 4px solid var(--accent-terracotta);
            box-shadow: 0 4px 20px rgba(0,0,0,0.1);
        }

        h1 {
            font-family: 'Libre Baskerville', serif;
            font-size: 3rem;
            font-weight: 700;
            letter-spacing: -0.5px;
            margin-bottom: 0.5rem;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
        }

        .subtitle {
            font-family: 'Crimson Pro', serif;
            font-size: 1.2rem;
            font-weight: 300;
            letter-spacing: 1px;
            opacity: 0.9;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 2rem;
        }

        .main-grid {
            display: grid;
            grid-template-columns: 1fr 400px;
            gap: 2rem;
            margin-top: 2rem;
        }

        @media (max-width: 1024px) {
            .main-grid {
                grid-template-columns: 1fr;
            }
        }

        .card {
            background: white;
            border-radius: 12px;
            padding: 2rem;
            box-shadow: 0 2px 12px rgba(44, 36, 22, 0.08);
            border: 1px solid var(--warm-beige);
        }

        .card-title {
            font-family: 'Libre Baskerville', serif;
            font-size: 1.5rem;
            color: var(--dark-brown);
            margin-bottom: 1.5rem;
            padding-bottom: 0.75rem;
            border-bottom: 2px solid var(--warm-beige);
        }

        .form-group {
            margin-bottom: 1.25rem;
        }

        label {
            display: block;
            font-weight: 500;
            margin-bottom: 0.5rem;
            color: var(--medium-brown);
            font-size: 0.9rem;
            letter-spacing: 0.3px;
        }

        input, select, textarea {
            width: 100%;
            padding: 0.75rem;
            border: 2px solid var(--warm-beige);
            border-radius: 6px;
            font-family: 'IBM Plex Sans', sans-serif;
            font-size: 1rem;
            transition: all 0.3s ease;
            background: var(--cream);
        }

        textarea {
            resize: vertical;
            min-height: 100px;
        }

        input:focus, select:focus {
            outline: none;
            border-color: var(--accent-terracotta);
            background: white;
            box-shadow: 0 0 0 3px rgba(193, 115, 79, 0.1);
        }

        .form-row {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 1rem;
        }

        button {
            background: var(--accent-terracotta);
            color: white;
            border: none;
            padding: 1rem 2rem;
            border-radius: 8px;
            font-family: 'IBM Plex Sans', sans-serif;
            font-size: 1rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 2px 8px rgba(193, 115, 79, 0.3);
            letter-spacing: 0.5px;
        }

        button:hover {
            background: var(--accent-burgundy);
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(193, 115, 79, 0.4);
        }

        button:active {
            transform: translateY(0);
        }

        .button-group {
            display: flex;
            gap: 1rem;
            margin-top: 1.5rem;
        }

        button.secondary {
            background: var(--accent-sage);
        }

        button.secondary:hover {
            background: #6a7e5d;
        }

        .stats-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 1rem;
            margin-bottom: 1.5rem;
        }

        .stat-box {
            background: linear-gradient(135deg, var(--warm-beige) 0%, var(--cream) 100%);
            padding: 1.25rem;
            border-radius: 8px;
            border-left: 4px solid var(--accent-terracotta);
        }

        .stat-label {
            font-size: 0.75rem;
            color: var(--medium-brown);
            text-transform: uppercase;
            letter-spacing: 1px;
            font-weight: 600;
            margin-bottom: 0.25rem;
        }

        .stat-value {
            font-family: 'Crimson Pro', serif;
            font-size: 2rem;
            font-weight: 700;
            color: var(--dark-brown);
        }

        .stat-detail {
            font-size: 0.85rem;
            color: var(--medium-brown);
            margin-top: 0.25rem;
        }

        .book-list {
            max-height: 600px;
            overflow-y: auto;
            margin-top: 1.5rem;
        }

        .book-item {
            background: var(--cream);
            padding: 1rem;
            margin-bottom: 0.75rem;
            border-radius: 8px;
            border-left: 3px solid var(--accent-sage);
            transition: all 0.3s ease;
        }

        .book-item:hover {
            background: white;
            transform: translateX(4px);
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        }

        .book-title {
            font-family: 'Crimson Pro', serif;
            font-size: 1.1rem;
            font-weight: 600;
            color: var(--dark-brown);
            margin-bottom: 0.25rem;
        }

        .book-meta {
            font-size: 0.85rem;
            color: var(--medium-brown);
            display: flex;
            flex-wrap: wrap;
            gap: 0.75rem;
        }

        .book-meta span {
            display: inline-flex;
            align-items: center;
        }

        .rating-stars {
            color: var(--light-gold);
            font-size: 1rem;
        }

        .loading {
            text-align: center;
            padding: 2rem;
            color: var(--medium-brown);
            font-style: italic;
        }

        .error {
            background: #fdd;
            color: #a00;
            padding: 1rem;
            border-radius: 6px;
            margin-top: 1rem;
            border-left: 4px solid #a00;
        }

        .success {
            background: #dfd;
            color: #060;
            padding: 1rem;
            border-radius: 6px;
            margin-top: 1rem;
            border-left: 4px solid #060;
        }

        .progress-bar {
            height: 6px;
            background: var(--warm-beige);
            border-radius: 3px;
            overflow: hidden;
            margin-top: 0.5rem;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, var(--accent-terracotta), var(--accent-burgundy));
            transition: width 0.5s ease;
        }

        .delete-btn {
            background: transparent;
            color: var(--accent-burgundy);
            padding: 0.25rem 0.5rem;
            font-size: 0.8rem;
            box-shadow: none;
            border: 1px solid var(--accent-burgundy);
            margin-left: 0.5rem;
        }

        .delete-btn:hover {
            background: var(--accent-burgundy);
            color: white;
        }

        .edit-btn {
            background: transparent;
            color: var(--accent-sage);
            padding: 0.25rem 0.5rem;
            font-size: 0.8rem;
            box-shadow: none;
            border: 1px solid var(--accent-sage);
        }

        .edit-btn:hover {
            background: var(--accent-sage);
            color: white;
        }

        .book-actions {
            margin-top: 0.5rem;
            display: flex;
            gap: 0.5rem;
        }

        .editing-banner {
            background: var(--accent-sage);
            color: white;
            padding: 0.75rem;
            border-radius: 6px;
            margin-bottom: 1rem;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .cancel-edit-btn {
            background: white;
            color: var(--accent-sage);
            padding: 0.5rem 1rem;
            font-size: 0.85rem;
        }

        .detailed-stats {
            margin-top: 1.5rem;
            padding-top: 1.5rem;
            border-top: 2px solid var(--warm-beige);
        }

        .stat-row {
            display: flex;
            justify-content: space-between;
            padding: 0.5rem 0;
            border-bottom: 1px solid var(--warm-beige);
        }

        .stat-row:last-child {
            border-bottom: none;
        }

        .trope-tag {
            display: inline-flex;
            align-items: center;
            gap: 0.25rem;
            padding: 0.25rem 0.5rem;
            background: linear-gradient(135deg, var(--accent-sage), var(--accent-terracotta));
            color: white;
            border-radius: 4px;
            font-size: 0.85rem;
            font-weight: 500;
        }

        .trope-tag button {
            background: none;
            border: none;
            color: white;
            cursor: pointer;
            padding: 0;
            margin-left: 0.25rem;
            font-size: 1rem;
            line-height: 1;
            opacity: 0.8;
            transition: opacity 0.2s;
        }

        .trope-tag button:hover {
            opacity: 1;
        }

        /* Report Modal Styles */
        .modal {
            display: none;
            position: fixed;
            z-index: 1000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0,0,0,0.7);
            overflow-y: auto;
        }

        .modal-content {
            background-color: var(--warm-white);
            margin: 2% auto;
            padding: 2rem;
            border-radius: 12px;
            width: 90%;
            max-width: 1200px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.3);
        }

        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 1.5rem;
            padding-bottom: 1rem;
            border-bottom: 2px solid var(--accent-terracotta);
        }

        .modal-close {
            color: var(--dark-brown);
            font-size: 2.5rem;
            font-weight: bold;
            cursor: pointer;
            line-height: 1;
            padding: 0 0.5rem;
            transition: all 0.2s ease;
        }

        .modal-close:hover {
            color: var(--accent-terracotta);
            transform: scale(1.1);
        }

        .date-filters {
            display: flex;
            gap: 1rem;
            margin-bottom: 1.5rem;
            flex-wrap: wrap;
            padding: 1rem;
            background: var(--warm-beige);
            border-radius: 8px;
        }

        .chart-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(400px, 1fr));
            gap: 2rem;
            margin-bottom: 2rem;
        }

        .chart-container {
            background: white;
            padding: 1.5rem;
            border-radius: 8px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        }

        .chart-title {
            font-family: 'Libre Baskerville', serif;
            font-size: 1.1rem;
            color: var(--dark-brown);
            margin-bottom: 1rem;
            text-align: center;
        }

        .top-books-list {
            background: white;
            padding: 1.5rem;
            border-radius: 8px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        }

        .top-book-item {
            padding: 0.75rem;
            border-bottom: 1px solid var(--warm-beige);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .top-book-item:last-child {
            border-bottom: none;
        }

        /* Clickable stat rows */
        .stat-row.clickable {
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .stat-row.clickable:hover {
            background: var(--warm-beige);
            transform: translateX(5px);
        }

        .filtered-books-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));
            gap: 1rem;
            margin-top: 1rem;
        }

        .filtered-book-card {
            background: white;
            padding: 1rem;
            border-radius: 8px;
            border-left: 4px solid var(--accent-terracotta);
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }

        .filtered-book-title {
            font-weight: 600;
            color: var(--dark-brown);
            margin-bottom: 0.25rem;
        }

        .filtered-book-author {
            color: var(--soft-brown);
            font-size: 0.9rem;
            margin-bottom: 0.5rem;
        }

        .filtered-book-details {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-top: 0.5rem;
            font-size: 0.9rem;
        }
    </style>
</head>
<body>
    <div class="header">
        <h1>üìö My 2026 Reading Journey</h1>
        <p class="subtitle">Track ¬∑ Discover ¬∑ Reflect</p>
    </div>

    <div class="container">
        <div class="main-grid">
            <div>
                <div class="card">
                    <h2 class="card-title">Add a Book</h2>
                    <div id="editingBanner"></div>
                    <div id="bookForm">
                        <div class="form-group">
                            <label for="title">Book Title *</label>
                            <input type="text" id="title" required placeholder="Enter book title...">
                        </div>
                        
                        <div class="form-group">
                            <label for="author">Author *</label>
                            <input type="text" id="author" required placeholder="Enter author name...">
                        </div>

                        <div class="form-group">
                            <label for="genre">Genre (optional - auto-filled if blank)</label>
                            <select id="genre">
                                <option value="">Auto-detect genre...</option>
                                <option value="Contemporary Romance">Contemporary Romance</option>
                                <option value="Romantasy">Romantasy</option>
                                <option value="Fantasy">Fantasy</option>
                                <option value="Historical Romance">Historical Romance</option>
                                <option value="Paranormal Romance">Paranormal Romance</option>
                                <option value="Dark Romance">Dark Romance</option>
                                <option value="Mystery/Thriller">Mystery/Thriller</option>
                                <option value="Literary Fiction">Literary Fiction</option>
                                <option value="Science Fiction">Science Fiction</option>
                                <option value="Horror">Horror</option>
                                <option value="Nonfiction">Nonfiction</option>
                                <option value="__custom__">+ Add Custom Genre...</option>
                            </select>
                            <input type="text" id="customGenre" placeholder="Enter custom genre..." style="display: none; margin-top: 0.5rem;">
                        </div>

                        <div class="form-group">
                            <label for="tropeSelect">Tropes (optional - select multiple)</label>
                            <div id="selectedTropes" style="display: flex; flex-wrap: wrap; gap: 0.5rem; margin-bottom: 0.5rem; min-height: 32px;"></div>
                            <select id="tropeSelect">
                                <option value="">+ Add trope...</option>
                                <option value="Enemies to Lovers">Enemies to Lovers</option>
                                <option value="Friends to Lovers">Friends to Lovers</option>
                                <option value="Forced Proximity">Forced Proximity</option>
                                <option value="Fake Dating/Relationship">Fake Dating/Relationship</option>
                                <option value="Second Chance Romance">Second Chance Romance</option>
                                <option value="Grumpy x Sunshine">Grumpy x Sunshine</option>
                                <option value="Only One Bed">Only One Bed</option>
                                <option value="Forbidden Love">Forbidden Love</option>
                                <option value="Marriage of Convenience">Marriage of Convenience</option>
                                <option value="Workplace Romance">Workplace Romance</option>
                                <option value="Brother's Best Friend">Brother's Best Friend</option>
                                <option value="Best Friend's Sibling">Best Friend's Sibling</option>
                                <option value="Small Town Romance">Small Town Romance</option>
                                <option value="Fated Mates">Fated Mates</option>
                                <option value="Age Gap">Age Gap</option>
                                <option value="Secret Relationship">Secret Relationship</option>
                                <option value="Slow Burn">Slow Burn</option>
                                <option value="Love Triangle">Love Triangle</option>
                                <option value="Opposites Attract">Opposites Attract</option>
                                <option value="Instalove">Instalove</option>
                                <option value="Hurt/Comfort">Hurt/Comfort</option>
                                <option value="Bodyguard Romance">Bodyguard Romance</option>
                                <option value="Roommates">Roommates</option>
                                <option value="Childhood Sweethearts">Childhood Sweethearts</option>
                                <option value="Fish Out of Water">Fish Out of Water</option>
                                <option value="Touch Her and Die">Touch Her and Die</option>
                                <option value="__custom__">‚úèÔ∏è Add Custom Trope...</option>
                            </select>
                            <input type="text" id="customTropeInput" placeholder="Enter custom trope and press Enter..." style="display: none; margin-top: 0.5rem;">
                        </div>

                        <div class="form-row">
                            <div class="form-group">
                                <label for="month">Month Read *</label>
                                <select id="month" required>
                                    <option value="">Select month...</option>
                                    <option value="January">January</option>
                                    <option value="February">February</option>
                                    <option value="March">March</option>
                                    <option value="April">April</option>
                                    <option value="May">May</option>
                                    <option value="June">June</option>
                                    <option value="July">July</option>
                                    <option value="August">August</option>
                                    <option value="September">September</option>
                                    <option value="October">October</option>
                                    <option value="November">November</option>
                                    <option value="December">December</option>
                                </select>
                            </div>

                            <div class="form-group">
                                <label for="format">Format *</label>
                                <select id="format" required>
                                    <option value="">Select format...</option>
                                    <option value="print">Print</option>
                                    <option value="digital">Digital</option>
                                    <option value="audio">Audio</option>
                                </select>
                            </div>
                        </div>

                        <div class="form-group">
                            <label for="rating">Your Rating (optional)</label>
                            <select id="rating">
                                <option value="">Not rated yet</option>
                                <option value="5">‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê 5 stars</option>
                                <option value="4.5">‚≠ê‚≠ê‚≠ê‚≠ê‚ú® 4.5 stars</option>
                                <option value="4">‚≠ê‚≠ê‚≠ê‚≠ê 4 stars</option>
                                <option value="3.5">‚≠ê‚≠ê‚≠ê‚ú® 3.5 stars</option>
                                <option value="3">‚≠ê‚≠ê‚≠ê 3 stars</option>
                                <option value="2.5">‚≠ê‚≠ê‚ú® 2.5 stars</option>
                                <option value="2">‚≠ê‚≠ê 2 stars</option>
                                <option value="1.5">‚≠ê‚ú® 1.5 stars</option>
                                <option value="1">‚≠ê 1 star</option>
                                <option value="0.5">‚ú® 0.5 stars</option>
                            </select>
                        </div>

                        <div class="form-row">
                            <div class="form-group">
                                <label for="recommender">Recommender (optional)</label>
                                <input type="text" id="recommender" placeholder="Who recommended this?">
                            </div>

                            <div class="form-group">
                                <label for="source">Source (optional)</label>
                                <select id="source">
                                    <option value="">Select source...</option>
                                    <option value="Library">Library</option>
                                    <option value="TBR">TBR</option>
                                    <option value="Purchased">Purchased</option>
                                </select>
                            </div>
                        </div>

                        <div class="form-row">
                            <div class="form-group">
                                <label for="authorGender">Author Gender (optional)</label>
                                <select id="authorGender">
                                    <option value="">Select gender...</option>
                                    <option value="Woman">Woman</option>
                                    <option value="Man">Man</option>
                                    <option value="Non-binary">Non-binary</option>
                                    <option value="Unknown">Unknown</option>
                                </select>
                            </div>

                            <div class="form-group">
                                <label for="authorRace">Author Race (optional)</label>
                                <select id="authorRace">
                                    <option value="">Select race...</option>
                                    <option value="White">White</option>
                                    <option value="Black">Black</option>
                                    <option value="Asian">Asian</option>
                                    <option value="Latina/o/x">Latina/o/x</option>
                                    <option value="Indigenous">Indigenous</option>
                                    <option value="Middle Eastern">Middle Eastern</option>
                                    <option value="Multiracial">Multiracial</option>
                                    <option value="Unknown">Unknown</option>
                                </select>
                            </div>
                        </div>

                        <div class="form-group">
                            <label for="notes">Your Thoughts/Notes (optional)</label>
                            <textarea id="notes" rows="4" placeholder="Jot down your thoughts about this book for social media posts later..."></textarea>
                        </div>

                        <div class="button-group">
                            <button type="button" id="addBtn">Add Book</button>
                            <button type="button" id="exportBtn" class="secondary">Export Data</button>
                        </div>
                    </div>
                    <div id="message"></div>
                </div>

                <div class="card" style="margin-top: 2rem;">
                    <h2 class="card-title">Books Read in 2026</h2>
                    <div id="bookList" class="book-list"></div>
                </div>
            </div>

            <div>
                <div class="card">
                    <h2 class="card-title">2026 Statistics</h2>
                    <button type="button" id="generateReportBtn" style="width: 100%; padding: 0.75rem; background: linear-gradient(135deg, var(--accent-sage), var(--accent-terracotta)); color: white; border: none; border-radius: 6px; font-weight: 600; cursor: pointer; margin-bottom: 1.5rem; font-size: 1rem;">
                        üìä Generate Detailed Report
                    </button>
                    <div id="stats"></div>
                </div>
            </div>
        </div>
    </div>

    <!-- Filtered Books Modal -->
    <div id="filteredBooksModal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h2 id="filteredBooksTitle" style="font-family: 'Libre Baskerville', serif; color: var(--dark-brown); margin: 0;"></h2>
                <span class="modal-close" onclick="closeFilteredBooksModal()">&times;</span>
            </div>
            <div id="filteredBooksContent"></div>
        </div>
    </div>

    <!-- Report Modal -->
    <div id="reportModal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h2 style="font-family: 'Libre Baskerville', serif; color: var(--dark-brown); margin: 0;">üìä Reading Report</h2>
                <span class="modal-close" onclick="closeReportModal()">&times;</span>
            </div>
            
            <div class="date-filters">
                <div>
                    <label style="font-weight: 600; margin-right: 0.5rem;">Filter by:</label>
                    <select id="reportPeriod" style="padding: 0.5rem; border-radius: 4px; border: 1px solid var(--soft-brown);">
                        <option value="all">All Time (2026)</option>
                        <option value="month">Specific Month</option>
                        <option value="custom">Custom Range</option>
                    </select>
                </div>
                <div id="monthSelector" style="display: none;">
                    <select id="reportMonth" style="padding: 0.5rem; border-radius: 4px; border: 1px solid var(--soft-brown);">
                        <option value="January">January</option>
                        <option value="February">February</option>
                        <option value="March">March</option>
                        <option value="April">April</option>
                        <option value="May">May</option>
                        <option value="June">June</option>
                        <option value="July">July</option>
                        <option value="August">August</option>
                        <option value="September">September</option>
                        <option value="October">October</option>
                        <option value="November">November</option>
                        <option value="December">December</option>
                    </select>
                </div>
                <button type="button" onclick="generateReport()" style="padding: 0.5rem 1rem; background: var(--accent-terracotta); color: white; border: none; border-radius: 4px; cursor: pointer; font-weight: 600;">
                    Update Report
                </button>
            </div>

            <div id="reportContent"></div>
        </div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.min.js"></script>
    <script>
        // Initialize with January 2026 books
        const initialBooks = [
            {
                id: Date.now() + 1,
                title: "Last on the List (Wait With Me #5)",
                author: "Amy Daws",
                month: "January",
                format: "print",
                rating: 3,
                recommender: null,
                source: null,
                authorGender: "Woman",
                authorRace: "White",
                tropes: null,
                notes: null,
                publisher: "Canary Street Press",
                pubYear: 2022,
                genre: "Contemporary Romance",
                addedDate: new Date().toISOString()
            },
            {
                id: Date.now() + 2,
                title: "Shield of Sparrows (Shield of Sparrows, #1)",
                author: "Devney Perry",
                month: "January",
                format: "digital",
                rating: 5,
                recommender: null,
                source: null,
                authorGender: "Woman",
                authorRace: "White",
                tropes: null,
                notes: null,
                publisher: "Entangled: Red Tower Books",
                pubYear: 2025,
                genre: "Romantasy",
                addedDate: new Date().toISOString()
            },
            {
                id: Date.now() + 3,
                title: "Heir of Fire (Throne of Glass, #3)",
                author: "Sarah J. Maas",
                month: "January",
                format: "digital",
                rating: 4,
                recommender: null,
                source: null,
                authorGender: "Woman",
                authorRace: "White",
                tropes: null,
                notes: null,
                publisher: "Bloomsbury Publishing",
                pubYear: 2014,
                genre: "Fantasy",
                addedDate: new Date().toISOString()
            },
            {
                id: Date.now() + 4,
                title: "Tourist Season (The Seasons of Carnage Trilogy, #1)",
                author: "Brynne Weaver",
                month: "January",
                format: "digital",
                rating: 3,
                recommender: null,
                source: null,
                authorGender: "Woman",
                authorRace: "White",
                tropes: null,
                notes: null,
                publisher: "Slowburn",
                pubYear: 2025,
                genre: "Dark Romance",
                addedDate: new Date().toISOString()
            },
            {
                id: Date.now() + 5,
                title: "Magical Midlife Madness [Dramatized Adaptation] (Leveling Up, #1)",
                author: "K.F. Breene",
                month: "January",
                format: "audio",
                rating: 3,
                recommender: null,
                source: null,
                authorGender: "Woman",
                authorRace: "White",
                tropes: null,
                notes: null,
                publisher: "Graphic Audio LLC",
                pubYear: 2024,
                genre: "Paranormal Romance",
                addedDate: new Date().toISOString()
            }
        ];

        let books = [];
        let editingBookId = null;
        let customGenres = [];
        let customTropes = [];
        let selectedTropes = [];

        // Render selected tropes as tags
        function renderTropeTags() {
            const container = document.getElementById('selectedTropes');
            container.innerHTML = selectedTropes.map((trope, index) => `
                <span class="trope-tag">
                    ${trope}
                    <button type="button" onclick="removeTrope(${index})" title="Remove">√ó</button>
                </span>
            `).join('');
        }

        // Add a trope to the selection
        function addTrope(trope) {
            if (trope && !selectedTropes.includes(trope)) {
                selectedTropes.push(trope);
                renderTropeTags();
            }
        }

        // Remove a trope from the selection
        function removeTrope(index) {
            selectedTropes.splice(index, 1);
            renderTropeTags();
        }

        // Load custom genres from storage
        async function loadCustomGenres() {
            try {
                if (window.storage && window.storage.get) {
                    const stored = await window.storage.get('reading-tracker-custom-genres');
                    if (stored && stored.value) {
                        customGenres = JSON.parse(stored.value);
                        updateGenreDropdown();
                    }
                } else {
                    const localData = localStorage.getItem('reading-tracker-custom-genres');
                    if (localData) {
                        customGenres = JSON.parse(localData);
                        updateGenreDropdown();
                    }
                }
            } catch (error) {
                console.log('No custom genres stored');
            }
        }

        // Load custom tropes from storage
        async function loadCustomTropes() {
            try {
                if (window.storage && window.storage.get) {
                    const stored = await window.storage.get('reading-tracker-custom-tropes');
                    if (stored && stored.value) {
                        customTropes = JSON.parse(stored.value);
                        updateTropeDropdown();
                    }
                } else {
                    const localData = localStorage.getItem('reading-tracker-custom-tropes');
                    if (localData) {
                        customTropes = JSON.parse(localData);
                        updateTropeDropdown();
                    }
                }
            } catch (error) {
                console.log('No custom tropes stored');
            }
        }

        // Save custom genres to storage
        async function saveCustomGenres() {
            try {
                if (window.storage && window.storage.set) {
                    await window.storage.set('reading-tracker-custom-genres', JSON.stringify(customGenres));
                } else {
                    localStorage.setItem('reading-tracker-custom-genres', JSON.stringify(customGenres));
                }
            } catch (error) {
                console.error('Error saving custom genres:', error);
            }
        }

        // Save custom tropes to storage
        async function saveCustomTropes() {
            try {
                if (window.storage && window.storage.set) {
                    await window.storage.set('reading-tracker-custom-tropes', JSON.stringify(customTropes));
                } else {
                    localStorage.setItem('reading-tracker-custom-tropes', JSON.stringify(customTropes));
                }
            } catch (error) {
                console.error('Error saving custom tropes:', error);
            }
        }

        // Update genre dropdown with custom genres
        function updateGenreDropdown() {
            const genreSelect = document.getElementById('genre');
            const customOption = genreSelect.querySelector('option[value="__custom__"]');
            
            // Remove any previously added custom genres
            const existingCustom = genreSelect.querySelectorAll('option[data-custom="true"]');
            existingCustom.forEach(opt => opt.remove());
            
            // Add custom genres before the "Add Custom" option
            customGenres.forEach(genre => {
                const option = document.createElement('option');
                option.value = genre;
                option.textContent = genre;
                option.setAttribute('data-custom', 'true');
                genreSelect.insertBefore(option, customOption);
            });
        }

        // Update trope dropdown with custom tropes
        function updateTropeDropdown() {
            const tropeSelect = document.getElementById('tropeSelect');
            const customOption = tropeSelect.querySelector('option[value="__custom__"]');
            
            // Remove any previously added custom tropes
            const existingCustom = tropeSelect.querySelectorAll('option[data-custom="true"]');
            existingCustom.forEach(opt => opt.remove());
            
            // Add custom tropes before the "Add Custom" option
            customTropes.forEach(trope => {
                const option = document.createElement('option');
                option.value = trope;
                option.textContent = trope;
                option.setAttribute('data-custom', 'true');
                tropeSelect.insertBefore(option, customOption);
            });
        }

        // Handle genre and trope selection changes
        document.addEventListener('DOMContentLoaded', () => {
            const genreSelect = document.getElementById('genre');
            const customGenreInput = document.getElementById('customGenre');
            const tropeSelect = document.getElementById('tropeSelect');
            const customTropeInput = document.getElementById('customTropeInput');
            
            genreSelect.addEventListener('change', (e) => {
                if (e.target.value === '__custom__') {
                    customGenreInput.style.display = 'block';
                    customGenreInput.focus();
                } else {
                    customGenreInput.style.display = 'none';
                    customGenreInput.value = '';
                }
            });
            
            tropeSelect.addEventListener('change', (e) => {
                if (e.target.value === '__custom__') {
                    customTropeInput.style.display = 'block';
                    customTropeInput.focus();
                    e.target.value = '';
                } else if (e.target.value) {
                    addTrope(e.target.value);
                    e.target.value = '';
                }
            });
            
            customGenreInput.addEventListener('blur', async () => {
                const newGenre = customGenreInput.value.trim();
                if (newGenre && !customGenres.includes(newGenre)) {
                    customGenres.push(newGenre);
                    await saveCustomGenres();
                    updateGenreDropdown();
                    genreSelect.value = newGenre;
                    customGenreInput.style.display = 'none';
                    customGenreInput.value = '';
                }
            });
            
            customTropeInput.addEventListener('keydown', async (e) => {
                if (e.key === 'Enter') {
                    e.preventDefault();
                    const newTrope = customTropeInput.value.trim();
                    if (newTrope) {
                        if (!customTropes.includes(newTrope)) {
                            customTropes.push(newTrope);
                            await saveCustomTropes();
                            updateTropeDropdown();
                        }
                        addTrope(newTrope);
                        customTropeInput.value = '';
                        customTropeInput.style.display = 'none';
                    }
                }
            });
            
            customTropeInput.addEventListener('blur', async () => {
                const newTrope = customTropeInput.value.trim();
                if (newTrope) {
                    if (!customTropes.includes(newTrope)) {
                        customTropes.push(newTrope);
                        await saveCustomTropes();
                        updateTropeDropdown();
                    }
                    addTrope(newTrope);
                    customTropeInput.value = '';
                }
                customTropeInput.style.display = 'none';
            });
        });

        // Function to clear all form fields
        function clearForm() {
            document.getElementById('title').value = '';
            document.getElementById('author').value = '';
            document.getElementById('genre').value = '';
            document.getElementById('customGenre').style.display = 'none';
            document.getElementById('customGenre').value = '';
            selectedTropes = [];
            renderTropeTags();
            document.getElementById('tropeSelect').value = '';
            document.getElementById('customTropeInput').style.display = 'none';
            document.getElementById('customTropeInput').value = '';
            document.getElementById('month').value = 'January';
            document.getElementById('format').value = 'print';
            document.getElementById('rating').value = '';
            document.getElementById('recommender').value = '';
            document.getElementById('source').value = '';
            document.getElementById('authorGender').value = '';
            document.getElementById('authorRace').value = '';
            document.getElementById('notes').value = '';
        }

        // Load books from storage or use initial data
        async function loadBooks() {
            try {
                let stored = null;
                if (window.storage && window.storage.get) {
                    stored = await window.storage.get('reading-tracker-2026');
                    if (stored && stored.value) {
                        books = JSON.parse(stored.value);
                    }
                } else {
                    // Fallback to localStorage
                    const localData = localStorage.getItem('reading-tracker-2026');
                    if (localData) {
                        books = JSON.parse(localData);
                    }
                }
                
                // If no stored data found, use initial books
                if (books.length === 0) {
                    books = [...initialBooks];
                    await saveBooks();
                } else {
                    // Migrate old data: match stored books with initial books and update missing fields
                    books.forEach(book => {
                        const matchingInitial = initialBooks.find(ib => 
                            ib.title === book.title && ib.author === book.author
                        );
                        if (matchingInitial) {
                            // Update with new fields from initial books if missing
                            if (!book.genre && matchingInitial.genre) {
                                book.genre = matchingInitial.genre;
                            }
                            if (!book.authorGender && matchingInitial.authorGender) {
                                book.authorGender = matchingInitial.authorGender;
                            }
                            if (!book.authorRace && matchingInitial.authorRace) {
                                book.authorRace = matchingInitial.authorRace;
                            }
                            if (!book.publisher && matchingInitial.publisher) {
                                book.publisher = matchingInitial.publisher;
                            }
                            if (!book.pubYear && matchingInitial.pubYear) {
                                book.pubYear = matchingInitial.pubYear;
                            }
                        }
                        // Ensure tropes is an array (for old data compatibility)
                        if (!book.tropes || !Array.isArray(book.tropes)) {
                            book.tropes = [];
                        }
                    });
                    await saveBooks(); // Save the migrated data
                }
            } catch (error) {
                console.log('Error loading data, using initial books:', error);
                books = [...initialBooks];
                await saveBooks();
            }
            renderBooks();
            updateStats();
        }

        async function saveBooks() {
            try {
                if (window.storage && window.storage.set) {
                    await window.storage.set('reading-tracker-2026', JSON.stringify(books));
                } else {
                    // Fallback to localStorage
                    localStorage.setItem('reading-tracker-2026', JSON.stringify(books));
                }
            } catch (error) {
                console.error('Error saving books:', error);
                // Try localStorage as fallback
                try {
                    localStorage.setItem('reading-tracker-2026', JSON.stringify(books));
                } catch (e) {
                    console.error('Fallback save also failed:', e);
                }
            }
        }

        document.getElementById('addBtn').addEventListener('click', async (e) => {
            e.preventDefault();
            
            const title = document.getElementById('title').value;
            const author = document.getElementById('author').value;
            let genre = document.getElementById('genre').value;
            
            // Handle custom genre
            if (genre === '__custom__') {
                const customGenreValue = document.getElementById('customGenre').value.trim();
                if (customGenreValue) {
                    genre = customGenreValue;
                    if (!customGenres.includes(customGenreValue)) {
                        customGenres.push(customGenreValue);
                        await saveCustomGenres();
                        updateGenreDropdown();
                    }
                } else {
                    genre = '';
                }
            }
            
            // Use selectedTropes array
            const tropes = selectedTropes.length > 0 ? [...selectedTropes] : null;
            
            const month = document.getElementById('month').value;
            const format = document.getElementById('format').value;
            const rating = document.getElementById('rating').value;
            const recommender = document.getElementById('recommender').value;
            const source = document.getElementById('source').value;
            const authorGender = document.getElementById('authorGender').value;
            const authorRace = document.getElementById('authorRace').value;
            const notes = document.getElementById('notes').value;

            const addBtn = document.getElementById('addBtn');
            const messageDiv = document.getElementById('message');
            
            // If editing, update existing book
            if (editingBookId) {
                addBtn.textContent = 'Updating...';
                addBtn.disabled = true;
                
                const bookIndex = books.findIndex(b => b.id === editingBookId);
                
                if (bookIndex !== -1) {
                    // Keep existing metadata but update user-editable fields
                    books[bookIndex] = {
                        ...books[bookIndex],
                        title,
                        author,
                        genre: genre || books[bookIndex].genre,
                        tropes: tropes || books[bookIndex].tropes,
                        month,
                        format,
                        rating: rating ? parseFloat(rating) : null,
                        recommender: recommender || null,
                        source: source || null,
                        authorGender: authorGender || null,
                        authorRace: authorRace || books[bookIndex].authorRace,
                        notes: notes || null
                    };
                    
                    try {
                        await saveBooks();
                        renderBooks();
                        updateStats();
                        
                        const editedBookId = editingBookId;
                        editingBookId = null;
                        updateEditingBanner();
                        clearForm();
                        addBtn.textContent = 'Add Book';
                        addBtn.disabled = false;
                        messageDiv.innerHTML = '<div class="success">‚úì Book updated successfully!</div>';
                        setTimeout(() => messageDiv.innerHTML = '', 3000);
                    } catch (error) {
                        console.error('Error updating book:', error);
                        addBtn.textContent = 'Update Book';
                        addBtn.disabled = false;
                        messageDiv.innerHTML = '<div class="error">Error updating book. Please try again.</div>';
                    }
                }
                return;
            }
            
            // Otherwise, add new book
            addBtn.textContent = 'Adding book...';
            addBtn.disabled = true;

            try {
                // Default book data
                let bookData = {
                    publisher: 'Unknown',
                    pubYear: null,
                    genre: genre || 'Unknown',
                    authorRace: authorRace || 'Unknown'
                };

                // Try to look up book details using Claude API with web search
                // This is optional - if it fails, we'll just use the defaults
                try {
                    const needsAuthorRace = !authorRace;
                    const needsGenre = !genre;
                    
                    if (needsAuthorRace || needsGenre) {
                        addBtn.textContent = 'Looking up book details...';
                        
                        const response = await fetch('https://api.anthropic.com/v1/messages', {
                            method: 'POST',
                            headers: {
                                'Content-Type': 'application/json',
                            },
                            body: JSON.stringify({
                                model: 'claude-sonnet-4-20250514',
                                max_tokens: 2000,
                                tools: [{
                                    type: "web_search_20250305",
                                    name: "web_search"
                                }],
                                messages: [{
                                    role: 'user',
                                    content: `For the book "${title}" by ${author}, search the web to find:
1. Publisher name
2. Publication year
${needsGenre ? '3. Primary genre (e.g., Contemporary Romance, Fantasy, Mystery, etc.)' : ''}
${needsAuthorRace ? '4. Author\'s race/ethnicity (search for biographical information about the author to determine this - use categories: White, Black, Asian, Latina/o/x, Indigenous, Middle Eastern, Multiracial, or Unknown if cannot be determined)' : ''}

Return ONLY a JSON object with this format (no other text):
{
  "publisher": "publisher name or 'Unknown'",
  "pubYear": publication year as number or null,
  ${needsGenre ? '"genre": "primary genre",' : ''}
  ${needsAuthorRace ? '"authorRace": "race/ethnicity or Unknown"' : ''}
}

Important: Use web search to find accurate information about the author's background and the book details.`
                                }]
                            })
                        });

                        if (response.ok) {
                            const data = await response.json();
                            const text = data.content.find(c => c.type === 'text')?.text || '';
                            try {
                                const parsed = JSON.parse(text.replace(/```json|```/g, '').trim());
                                bookData = {
                                    publisher: parsed.publisher || bookData.publisher,
                                    pubYear: parsed.pubYear || bookData.pubYear,
                                    genre: genre || parsed.genre || bookData.genre,
                                    authorRace: authorRace || parsed.authorRace || bookData.authorRace
                                };
                            } catch (e) {
                                console.log('Could not parse API response, using defaults');
                            }
                        }
                    }
                } catch (apiError) {
                    console.log('API lookup failed, using default values:', apiError);
                    // Continue with default values - this is not critical
                }

                const newBook = {
                    id: Date.now(),
                    title,
                    author,
                    month,
                    format,
                    rating: rating ? parseFloat(rating) : null,
                    recommender: recommender || null,
                    source: source || null,
                    authorGender: authorGender || null,
                    authorRace: bookData.authorRace,
                    tropes: tropes,
                    notes: notes || null,
                    publisher: bookData.publisher,
                    pubYear: bookData.pubYear,
                    genre: bookData.genre,
                    addedDate: new Date().toISOString()
                };

                books.push(newBook);
                await saveBooks();
                renderBooks();
                updateStats();
                
                clearForm();
                messageDiv.innerHTML = '<div class="success">‚úì Book added successfully!</div>';
                setTimeout(() => messageDiv.innerHTML = '', 3000);
            } catch (error) {
                console.error('Error:', error);
                messageDiv.innerHTML = '<div class="error">Error adding book. Please try again.</div>';
            } finally {
                addBtn.textContent = 'Add Book';
                addBtn.disabled = false;
            }
        });

        // Function to display stars with half-star support
        function displayStars(rating) {
            if (!rating) return '';
            const fullStars = Math.floor(rating);
            const hasHalfStar = rating % 1 !== 0;
            return '‚≠ê'.repeat(fullStars) + (hasHalfStar ? '‚ú®' : '');
        }

        function renderBooks() {
            const listDiv = document.getElementById('bookList');
            if (books.length === 0) {
                listDiv.innerHTML = '<p class="loading">No books yet. Add your first book above!</p>';
                return;
            }

            const sortedBooks = [...books].sort((a, b) => 
                new Date(b.addedDate) - new Date(a.addedDate)
            );

            listDiv.innerHTML = sortedBooks.map(book => `
                <div class="book-item">
                    <div class="book-title">${book.title}</div>
                    <div class="book-meta">
                        <span>by ${book.author}</span>
                        <span>‚Ä¢</span>
                        <span>${book.month}</span>
                        <span>‚Ä¢</span>
                        <span>${book.format}</span>
                        ${book.rating ? `<span>‚Ä¢</span><span class="rating-stars">${displayStars(book.rating)}</span>` : ''}
                        ${book.genre ? `<span>‚Ä¢</span><span>üìñ ${book.genre}</span>` : ''}
                        ${book.tropes && book.tropes.length > 0 ? `<span>‚Ä¢</span><span>üíï ${book.tropes.join(', ')}</span>` : ''}
                        ${book.source ? `<span>‚Ä¢</span><span>üìö ${book.source}</span>` : ''}
                        ${book.recommender ? `<span>‚Ä¢</span><span>üí° ${book.recommender}</span>` : ''}
                        ${book.publisher && book.publisher !== 'Unknown' ? `<span>‚Ä¢</span><span>${book.publisher}</span>` : ''}
                    </div>
                    ${book.notes ? `<div style="margin-top: 0.5rem; padding: 0.5rem; background: var(--warm-beige); border-left: 3px solid var(--accent-terracotta); font-size: 0.9rem; font-style: italic;">üìù ${book.notes}</div>` : ''}
                    <div class="book-actions">
                        <button class="edit-btn" onclick="editBook(${book.id})">Edit</button>
                        <button class="delete-btn" onclick="deleteBook(${book.id})">Delete</button>
                    </div>
                </div>
            `).join('');
        }

        function editBook(id) {
            const book = books.find(b => b.id === id);
            if (!book) return;

            // Populate form with book data
            document.getElementById('title').value = book.title;
            document.getElementById('author').value = book.author;
            
            // Handle genre - check if it's in the dropdown
            const genreSelect = document.getElementById('genre');
            const genreExists = Array.from(genreSelect.options).some(opt => opt.value === book.genre);
            
            if (book.genre && genreExists) {
                genreSelect.value = book.genre;
            } else if (book.genre) {
                // It's a custom genre that's not in the list yet
                if (!customGenres.includes(book.genre)) {
                    customGenres.push(book.genre);
                    saveCustomGenres();
                    updateGenreDropdown();
                }
                genreSelect.value = book.genre;
            } else {
                genreSelect.value = '';
            }
            
            document.getElementById('customGenre').style.display = 'none';
            document.getElementById('customGenre').value = '';
            
            // Handle tropes array - populate selectedTropes
            selectedTropes = book.tropes ? [...book.tropes] : [];
            
            // Add any custom tropes to the dropdown if needed
            if (book.tropes) {
                book.tropes.forEach(trope => {
                    const tropeSelect = document.getElementById('tropeSelect');
                    const tropeExists = Array.from(tropeSelect.options).some(opt => opt.value === trope);
                    if (!tropeExists && !customTropes.includes(trope) && trope !== '__custom__') {
                        customTropes.push(trope);
                        saveCustomTropes();
                        updateTropeDropdown();
                    }
                });
            }
            
            renderTropeTags();
            document.getElementById('tropeSelect').value = '';
            document.getElementById('customTropeInput').style.display = 'none';
            document.getElementById('customTropeInput').value = '';
            
            document.getElementById('month').value = book.month;
            document.getElementById('format').value = book.format;
            document.getElementById('rating').value = book.rating || '';
            document.getElementById('recommender').value = book.recommender || '';
            document.getElementById('source').value = book.source || '';
            document.getElementById('authorGender').value = book.authorGender || '';
            document.getElementById('authorRace').value = book.authorRace || '';
            document.getElementById('notes').value = book.notes || '';

            // Set editing state
            editingBookId = id;
            updateEditingBanner();
            
            // Update button text
            document.getElementById('addBtn').textContent = 'Update Book';

            // Scroll to form
            document.getElementById('bookForm').scrollIntoView({ behavior: 'smooth' });
        }

        function cancelEdit() {
            editingBookId = null;
            clearForm();
            document.getElementById('addBtn').textContent = 'Add Book';
            updateEditingBanner();
        }

        function updateEditingBanner() {
            const banner = document.getElementById('editingBanner');
            if (editingBookId) {
                const book = books.find(b => b.id === editingBookId);
                banner.innerHTML = `
                    <div class="editing-banner">
                        <span>‚úèÔ∏è Editing: <strong>${book.title}</strong></span>
                        <button class="cancel-edit-btn" onclick="cancelEdit()">Cancel</button>
                    </div>
                `;
            } else {
                banner.innerHTML = '';
            }
        }

        async function deleteBook(id) {
            if (confirm('Are you sure you want to delete this book?')) {
                books = books.filter(b => b.id !== id);
                
                // If deleting the book we're editing, cancel edit mode
                if (editingBookId === id) {
                    cancelEdit();
                }
                
                await saveBooks();
                renderBooks();
                updateStats();
            }
        }

        function updateStats() {
            const statsDiv = document.getElementById('stats');
            const totalBooks = books.length;
            const ratedBooks = books.filter(b => b.rating).length;
            const avgRating = ratedBooks > 0 
                ? (books.filter(b => b.rating).reduce((sum, b) => sum + b.rating, 0) / ratedBooks).toFixed(2)
                : 0;

            // Calculate average rating by category
            function getAvgRating(filterFunc) {
                const filtered = books.filter(filterFunc).filter(b => b.rating);
                return filtered.length > 0 
                    ? (filtered.reduce((sum, b) => sum + b.rating, 0) / filtered.length).toFixed(2)
                    : 'N/A';
            }

            const formatCounts = {
                print: books.filter(b => b.format === 'print').length,
                digital: books.filter(b => b.format === 'digital').length,
                audio: books.filter(b => b.format === 'audio').length
            };

            const formatRatings = {
                print: getAvgRating(b => b.format === 'print'),
                digital: getAvgRating(b => b.format === 'digital'),
                audio: getAvgRating(b => b.format === 'audio')
            };

            // Source stats
            const sourceCounts = {};
            const sourceRatings = {};
            ['Library', 'TBR', 'Purchased'].forEach(source => {
                sourceCounts[source] = books.filter(b => b.source === source).length;
                sourceRatings[source] = getAvgRating(b => b.source === source);
            });

            // Genre stats
            const genreCounts = {};
            const genreRatings = {};
            books.forEach(b => {
                if (b.genre && b.genre !== 'Unknown') {
                    genreCounts[b.genre] = (genreCounts[b.genre] || 0) + 1;
                }
            });
            Object.keys(genreCounts).forEach(genre => {
                genreRatings[genre] = getAvgRating(b => b.genre === genre);
            });

            // Trope stats
            const tropeCounts = {};
            const tropeRatingSum = {};
            const tropeRatingCount = {};
            books.forEach(b => {
                if (b.tropes && Array.isArray(b.tropes)) {
                    b.tropes.forEach(trope => {
                        if (trope) {
                            tropeCounts[trope] = (tropeCounts[trope] || 0) + 1;
                            if (b.rating) {
                                tropeRatingSum[trope] = (tropeRatingSum[trope] || 0) + b.rating;
                                tropeRatingCount[trope] = (tropeRatingCount[trope] || 0) + 1;
                            }
                        }
                    });
                }
            });
            const tropeRatings = {};
            Object.keys(tropeCounts).forEach(trope => {
                tropeRatings[trope] = tropeRatingCount[trope] 
                    ? (tropeRatingSum[trope] / tropeRatingCount[trope]).toFixed(2)
                    : 'N/A';
            });

            const monthCounts = {};
            books.forEach(b => {
                monthCounts[b.month] = (monthCounts[b.month] || 0) + 1;
            });

            const currentMonth = new Date().toLocaleString('default', { month: 'long' });
            const booksThisMonth = monthCounts[currentMonth] || 0;

            // Calculate library savings
            const libraryBooks = books.filter(b => b.source === 'Library');
            const librarySavings = libraryBooks.reduce((total, book) => {
                // Estimated costs based on format
                const costs = {
                    'print': 16.99,      // Average print book cost
                    'digital': 12.99,    // Average Kindle book cost
                    'audio': 22.99       // Average audiobook cost
                };
                return total + (costs[book.format] || 15.99);
            }, 0);

            // Sort genres by count
            const sortedGenres = Object.entries(genreCounts).sort((a, b) => b[1] - a[1]);

            // Sort tropes by average rating (highest first)
            const sortedTropes = Object.entries(tropeCounts).sort((a, b) => {
                const ratingA = parseFloat(tropeRatings[a[0]]) || 0;
                const ratingB = parseFloat(tropeRatings[b[0]]) || 0;
                return ratingB - ratingA;
            });

            // Author gender stats
            const genderCounts = {};
            const genderRatings = {};
            books.forEach(b => {
                if (b.authorGender && b.authorGender !== 'Unknown') {
                    genderCounts[b.authorGender] = (genderCounts[b.authorGender] || 0) + 1;
                }
            });
            Object.keys(genderCounts).forEach(gender => {
                genderRatings[gender] = getAvgRating(b => b.authorGender === gender);
            });
            const sortedGenders = Object.entries(genderCounts).sort((a, b) => b[1] - a[1]);

            // Author race stats
            const raceCounts = {};
            const raceRatings = {};
            books.forEach(b => {
                if (b.authorRace && b.authorRace !== 'Unknown') {
                    raceCounts[b.authorRace] = (raceCounts[b.authorRace] || 0) + 1;
                }
            });
            Object.keys(raceCounts).forEach(race => {
                raceRatings[race] = getAvgRating(b => b.authorRace === race);
            });
            const sortedRaces = Object.entries(raceCounts).sort((a, b) => b[1] - a[1]);

            // Publisher stats
            const publisherCounts = {};
            const publisherRatings = {};
            books.forEach(b => {
                if (b.publisher && b.publisher !== 'Unknown') {
                    publisherCounts[b.publisher] = (publisherCounts[b.publisher] || 0) + 1;
                }
            });
            Object.keys(publisherCounts).forEach(publisher => {
                publisherRatings[publisher] = getAvgRating(b => b.publisher === publisher);
            });
            const sortedPublishers = Object.entries(publisherCounts).sort((a, b) => b[1] - a[1]);

            // Publication year stats
            const yearCounts = {};
            const yearRatings = {};
            books.forEach(b => {
                if (b.pubYear) {
                    yearCounts[b.pubYear] = (yearCounts[b.pubYear] || 0) + 1;
                }
            });
            Object.keys(yearCounts).forEach(year => {
                yearRatings[year] = getAvgRating(b => b.pubYear == year);
            });
            const sortedYears = Object.entries(yearCounts).sort((a, b) => b[0] - a[0]); // Sort by year descending

            statsDiv.innerHTML = `
                <div class="stats-grid">
                    <div class="stat-box">
                        <div class="stat-label">Total Books</div>
                        <div class="stat-value">${totalBooks}</div>
                        <div class="stat-detail">in 2026</div>
                    </div>
                    <div class="stat-box">
                        <div class="stat-label">This Month</div>
                        <div class="stat-value">${booksThisMonth}</div>
                        <div class="stat-detail">${currentMonth}</div>
                    </div>
                    <div class="stat-box">
                        <div class="stat-label">Avg Rating</div>
                        <div class="stat-value">${avgRating}</div>
                        <div class="stat-detail">${ratedBooks} rated</div>
                    </div>
                    <div class="stat-box">
                        <div class="stat-label">Goal Progress</div>
                        <div class="stat-value">${Math.round((totalBooks / 184) * 100)}%</div>
                        <div class="stat-detail">of 2025's 184</div>
                        <div class="progress-bar">
                            <div class="progress-fill" style="width: ${Math.min((totalBooks / 184) * 100, 100)}%"></div>
                        </div>
                    </div>
                </div>

                ${libraryBooks.length > 0 ? `
                    <div style="background: linear-gradient(135deg, var(--accent-sage) 0%, var(--accent-terracotta) 100%); color: white; padding: 1.5rem; border-radius: 8px; margin: 1.5rem 0; text-align: center; box-shadow: 0 4px 6px rgba(0,0,0,0.1);">
                        <div style="font-size: 0.9rem; font-weight: 600; text-transform: uppercase; letter-spacing: 1px; margin-bottom: 0.5rem;">üìö Library Savings in 2026</div>
                        <div style="font-size: 2.5rem; font-weight: bold; font-family: 'Libre Baskerville', serif;">$${librarySavings.toFixed(2)}</div>
                        <div style="font-size: 0.9rem; opacity: 0.95; margin-top: 0.5rem;">${libraryBooks.length} ${libraryBooks.length === 1 ? 'book' : 'books'} borrowed from the library</div>
                        <div style="font-size: 0.75rem; opacity: 0.85; margin-top: 0.75rem; border-top: 1px solid rgba(255,255,255,0.3); padding-top: 0.75rem;">
                            <div style="display: flex; justify-content: center; gap: 1.5rem; flex-wrap: wrap;">
                                ${libraryBooks.filter(b => b.format === 'print').length > 0 ? `<span>üìñ Print: ${libraryBooks.filter(b => b.format === 'print').length} books ($${(libraryBooks.filter(b => b.format === 'print').length * 16.99).toFixed(2)})</span>` : ''}
                                ${libraryBooks.filter(b => b.format === 'digital').length > 0 ? `<span>üì± Digital: ${libraryBooks.filter(b => b.format === 'digital').length} books ($${(libraryBooks.filter(b => b.format === 'digital').length * 12.99).toFixed(2)})</span>` : ''}
                                ${libraryBooks.filter(b => b.format === 'audio').length > 0 ? `<span>üéß Audio: ${libraryBooks.filter(b => b.format === 'audio').length} books ($${(libraryBooks.filter(b => b.format === 'audio').length * 22.99).toFixed(2)})</span>` : ''}
                            </div>
                        </div>
                    </div>
                ` : ''}

                <div class="detailed-stats">
                    <h3 style="font-family: 'Libre Baskerville', serif; font-size: 1.1rem; margin: 1.5rem 0 1rem 0; color: var(--dark-brown);">Format Breakdown</h3>
                    <div class="stat-row clickable" onclick="showBooksByFilter('format', 'print')">
                        <span>üìñ Print</span>
                        <span><strong>${formatCounts.print}</strong> (${totalBooks ? Math.round((formatCounts.print/totalBooks)*100) : 0}%) ¬∑ ‚≠ê ${formatRatings.print}</span>
                    </div>
                    <div class="stat-row clickable" onclick="showBooksByFilter('format', 'digital')">
                        <span>üì± Digital</span>
                        <span><strong>${formatCounts.digital}</strong> (${totalBooks ? Math.round((formatCounts.digital/totalBooks)*100) : 0}%) ¬∑ ‚≠ê ${formatRatings.digital}</span>
                    </div>
                    <div class="stat-row clickable" onclick="showBooksByFilter('format', 'audio')">
                        <span>üéß Audio</span>
                        <span><strong>${formatCounts.audio}</strong> (${totalBooks ? Math.round((formatCounts.audio/totalBooks)*100) : 0}%) ¬∑ ‚≠ê ${formatRatings.audio}</span>
                    </div>

                    ${Object.keys(sourceCounts).some(k => sourceCounts[k] > 0) ? `
                        <h3 style="font-family: 'Libre Baskerville', serif; font-size: 1.1rem; margin: 1.5rem 0 1rem 0; color: var(--dark-brown);">Source Breakdown</h3>
                        ${sourceCounts.Library > 0 ? `<div class="stat-row clickable" onclick="showBooksByFilter('source', 'Library')">
                            <span>üìö Library</span>
                            <span><strong>${sourceCounts.Library}</strong> (${totalBooks ? Math.round((sourceCounts.Library/totalBooks)*100) : 0}%) ¬∑ ‚≠ê ${sourceRatings.Library}</span>
                        </div>` : ''}
                        ${sourceCounts.TBR > 0 ? `<div class="stat-row clickable" onclick="showBooksByFilter('source', 'TBR')">
                            <span>üìñ TBR</span>
                            <span><strong>${sourceCounts.TBR}</strong> (${totalBooks ? Math.round((sourceCounts.TBR/totalBooks)*100) : 0}%) ¬∑ ‚≠ê ${sourceRatings.TBR}</span>
                        </div>` : ''}
                        ${sourceCounts.Purchased > 0 ? `<div class="stat-row clickable" onclick="showBooksByFilter('source', 'Purchased')">
                            <span>üí∞ Purchased</span>
                            <span><strong>${sourceCounts.Purchased}</strong> (${totalBooks ? Math.round((sourceCounts.Purchased/totalBooks)*100) : 0}%) ¬∑ ‚≠ê ${sourceRatings.Purchased}</span>
                        </div>` : ''}
                    ` : ''}

                    ${sortedGenres.length > 0 ? `
                        <h3 style="font-family: 'Libre Baskerville', serif; font-size: 1.1rem; margin: 1.5rem 0 1rem 0; color: var(--dark-brown);">Genre Breakdown</h3>
                        ${(() => {
                            // Separate romance subgenres from other genres
                            const romanceGenres = [];
                            const otherGenres = [];
                            
                            sortedGenres.forEach(([genre, count]) => {
                                if (genre.toLowerCase().includes('romance') || genre === 'Romantasy') {
                                    romanceGenres.push([genre, count]);
                                } else {
                                    otherGenres.push([genre, count]);
                                }
                            });
                            
                            let html = '';
                            
                            // If there are romance genres, show grouped Romance first
                            if (romanceGenres.length > 0) {
                                const totalRomanceCount = romanceGenres.reduce((sum, [_, count]) => sum + count, 0);
                                
                                // Calculate average rating for all romance
                                const romanceBooks = books.filter(b => 
                                    b.genre && (b.genre.toLowerCase().includes('romance') || b.genre === 'Romantasy')
                                );
                                const romanceRatedBooks = romanceBooks.filter(b => b.rating);
                                const romanceAvgRating = romanceRatedBooks.length > 0
                                    ? (romanceRatedBooks.reduce((sum, b) => sum + b.rating, 0) / romanceRatedBooks.length).toFixed(2)
                                    : 'N/A';
                                
                                // Overall Romance row
                                html += `
                                    <div class="stat-row clickable" onclick="showBooksByFilter('romance', '')" style="background: linear-gradient(90deg, rgba(139, 165, 153, 0.1), transparent); font-weight: 600; border-left: 3px solid var(--accent-terracotta);">
                                        <span>üíñ Romance (All Types)</span>
                                        <span><strong>${totalRomanceCount}</strong> (${totalBooks ? Math.round((totalRomanceCount/totalBooks)*100) : 0}%) ¬∑ ‚≠ê ${romanceAvgRating}</span>
                                    </div>
                                `;
                                
                                // Romance subgenres (indented)
                                romanceGenres.forEach(([genre, count]) => {
                                    html += `
                                        <div class="stat-row clickable" onclick="showBooksByFilter('genre', '${genre}')" style="padding-left: 2rem; font-size: 0.95rem; color: var(--soft-brown);">
                                            <span>‚Ü≥ ${genre}</span>
                                            <span><strong>${count}</strong> (${totalBooks ? Math.round((count/totalBooks)*100) : 0}%) ¬∑ ‚≠ê ${genreRatings[genre]}</span>
                                        </div>
                                    `;
                                });
                            }
                            
                            // Other genres (not romance)
                            otherGenres.forEach(([genre, count]) => {
                                html += `
                                    <div class="stat-row clickable" onclick="showBooksByFilter('genre', '${genre}')">
                                        <span>${genre}</span>
                                        <span><strong>${count}</strong> (${totalBooks ? Math.round((count/totalBooks)*100) : 0}%) ¬∑ ‚≠ê ${genreRatings[genre]}</span>
                                    </div>
                                `;
                            });
                            
                            return html;
                        })()}
                    ` : ''}

                    ${sortedTropes.length > 0 ? `
                        <h3 style="font-family: 'Libre Baskerville', serif; font-size: 1.1rem; margin: 1.5rem 0 1rem 0; color: var(--dark-brown);">üíï Tropes (sorted by highest rating)</h3>
                        ${sortedTropes.map(([trope, count]) => `
                            <div class="stat-row clickable" onclick="showBooksByFilter('trope', '${trope}')">
                                <span>${trope}</span>
                                <span><strong>${count}</strong> books ¬∑ ‚≠ê ${tropeRatings[trope]}</span>
                            </div>
                        `).join('')}
                    ` : ''}

                    ${sortedGenders.length > 0 ? `
                        <h3 style="font-family: 'Libre Baskerville', serif; font-size: 1.1rem; margin: 1.5rem 0 1rem 0; color: var(--dark-brown);">Author Gender</h3>
                        ${sortedGenders.map(([gender, count]) => `
                            <div class="stat-row clickable" onclick="showBooksByFilter('gender', '${gender}')">
                                <span>${gender}</span>
                                <span><strong>${count}</strong> (${totalBooks ? Math.round((count/totalBooks)*100) : 0}%) ¬∑ ‚≠ê ${genderRatings[gender]}</span>
                            </div>
                        `).join('')}
                    ` : ''}

                    ${sortedRaces.length > 0 ? `
                        <h3 style="font-family: 'Libre Baskerville', serif; font-size: 1.1rem; margin: 1.5rem 0 1rem 0; color: var(--dark-brown);">Author Race</h3>
                        ${sortedRaces.map(([race, count]) => `
                            <div class="stat-row clickable" onclick="showBooksByFilter('race', '${race}')">
                                <span>${race}</span>
                                <span><strong>${count}</strong> (${totalBooks ? Math.round((count/totalBooks)*100) : 0}%) ¬∑ ‚≠ê ${raceRatings[race]}</span>
                            </div>
                        `).join('')}
                    ` : ''}

                    ${sortedPublishers.length > 0 ? `
                        <h3 style="font-family: 'Libre Baskerville', serif; font-size: 1.1rem; margin: 1.5rem 0 1rem 0; color: var(--dark-brown);">Publishers</h3>
                        ${sortedPublishers.map(([publisher, count]) => `
                            <div class="stat-row clickable" onclick="showBooksByFilter('publisher', '${publisher}')">
                                <span>${publisher}</span>
                                <span><strong>${count}</strong> (${totalBooks ? Math.round((count/totalBooks)*100) : 0}%) ¬∑ ‚≠ê ${publisherRatings[publisher]}</span>
                            </div>
                        `).join('')}
                    ` : ''}

                    ${sortedYears.length > 0 ? `
                        <h3 style="font-family: 'Libre Baskerville', serif; font-size: 1.1rem; margin: 1.5rem 0 1rem 0; color: var(--dark-brown);">Publication Years</h3>
                        ${sortedYears.map(([year, count]) => `
                            <div class="stat-row clickable" onclick="showBooksByFilter('year', '${year}')">
                                <span>${year}</span>
                                <span><strong>${count}</strong> (${totalBooks ? Math.round((count/totalBooks)*100) : 0}%) ¬∑ ‚≠ê ${yearRatings[year]}</span>
                            </div>
                        `).join('')}
                    ` : ''}
                </div>
            `;
        }

        document.getElementById('exportBtn').addEventListener('click', () => {
            const csv = [
                ['Title', 'Author', 'Month', 'Format', 'Rating', 'Source', 'Recommender', 'Author Gender', 'Author Race', 'Publisher', 'Publication Year', 'Genre', 'Tropes', 'Notes', 'Date Added'],
                ...books.map(b => [
                    b.title,
                    b.author,
                    b.month,
                    b.format,
                    b.rating || '',
                    b.source || '',
                    b.recommender || '',
                    b.authorGender || '',
                    b.authorRace || '',
                    b.publisher || '',
                    b.pubYear || '',
                    b.genre || '',
                    b.tropes && b.tropes.length > 0 ? b.tropes.join('; ') : '',
                    (b.notes || '').replace(/,/g, ';').replace(/\n/g, ' '),
                    new Date(b.addedDate).toLocaleDateString()
                ])
            ].map(row => row.join(',')).join('\n');

            const blob = new Blob([csv], { type: 'text/csv' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `reading-tracker-2026-${new Date().toISOString().split('T')[0]}.csv`;
            a.click();
            URL.revokeObjectURL(url);
        });

        // Initialize
        loadBooks();
        loadCustomGenres();
        loadCustomTropes();

        // Report Modal Functions
        function openReportModal() {
            document.getElementById('reportModal').style.display = 'block';
            generateReport();
        }

        function closeReportModal() {
            document.getElementById('reportModal').style.display = 'none';
        }

        // Close modal when clicking outside
        window.onclick = function(event) {
            const reportModal = document.getElementById('reportModal');
            const filteredModal = document.getElementById('filteredBooksModal');
            if (event.target == reportModal) {
                closeReportModal();
            }
            if (event.target == filteredModal) {
                closeFilteredBooksModal();
            }
        }

        // Close modals with Escape key
        document.addEventListener('keydown', function(event) {
            if (event.key === 'Escape' || event.key === 'Esc') {
                closeReportModal();
                closeFilteredBooksModal();
            }
        });

        // Filtered Books Modal Functions
        function openFilteredBooksModal(filterType, filterValue, books) {
            const modal = document.getElementById('filteredBooksModal');
            const title = document.getElementById('filteredBooksTitle');
            const content = document.getElementById('filteredBooksContent');
            
            // Set title
            title.textContent = `üìö Books in: ${filterValue}`;
            
            // Sort books by rating (highest first), then by title
            const sortedBooks = [...books].sort((a, b) => {
                if (b.rating !== a.rating) {
                    return (b.rating || 0) - (a.rating || 0);
                }
                return a.title.localeCompare(b.title);
            });
            
            // Display books
            content.innerHTML = `
                <div style="margin-bottom: 1rem; color: var(--soft-brown);">
                    Found ${sortedBooks.length} book${sortedBooks.length !== 1 ? 's' : ''}
                </div>
                <div class="filtered-books-grid">
                    ${sortedBooks.map(book => `
                        <div class="filtered-book-card">
                            <div class="filtered-book-title">${book.title}</div>
                            <div class="filtered-book-author">by ${book.author}</div>
                            ${book.rating ? `
                                <div class="rating-stars">${displayStars(book.rating)}</div>
                            ` : ''}
                            <div class="filtered-book-details">
                                <span>${book.month}</span>
                                <span style="text-transform: capitalize;">${book.format}</span>
                            </div>
                            ${book.notes ? `
                                <div style="margin-top: 0.5rem; font-size: 0.85rem; color: var(--soft-brown); font-style: italic;">
                                    "${book.notes.substring(0, 100)}${book.notes.length > 100 ? '...' : ''}"
                                </div>
                            ` : ''}
                        </div>
                    `).join('')}
                </div>
                <div style="text-align: center; margin-top: 2rem;">
                    <button type="button" onclick="closeFilteredBooksModal()" style="padding: 0.75rem 2rem; background: var(--accent-sage); color: white; border: none; border-radius: 6px; cursor: pointer; font-weight: 600; font-size: 1rem;">
                        Close
                    </button>
                </div>
            `;
            
            modal.style.display = 'block';
        }

        function closeFilteredBooksModal() {
            document.getElementById('filteredBooksModal').style.display = 'none';
        }

        // Filter and show books by criteria
        function showBooksByFilter(filterType, filterValue) {
            let filteredBooks = [];
            
            switch(filterType) {
                case 'format':
                    filteredBooks = books.filter(b => b.format === filterValue);
                    break;
                case 'source':
                    filteredBooks = books.filter(b => b.source === filterValue);
                    break;
                case 'genre':
                    filteredBooks = books.filter(b => b.genre === filterValue);
                    break;
                case 'romance':
                    // All romance subgenres
                    filteredBooks = books.filter(b => 
                        b.genre && (b.genre.toLowerCase().includes('romance') || b.genre === 'Romantasy')
                    );
                    filterValue = 'Romance (All Types)';
                    break;
                case 'trope':
                    filteredBooks = books.filter(b => 
                        b.tropes && Array.isArray(b.tropes) && b.tropes.includes(filterValue)
                    );
                    break;
                case 'gender':
                    filteredBooks = books.filter(b => b.authorGender === filterValue);
                    break;
                case 'race':
                    filteredBooks = books.filter(b => b.authorRace === filterValue);
                    break;
                case 'publisher':
                    filteredBooks = books.filter(b => b.publisher === filterValue);
                    break;
                case 'year':
                    filteredBooks = books.filter(b => b.pubYear == filterValue);
                    break;
            }
            
            if (filteredBooks.length > 0) {
                openFilteredBooksModal(filterType, filterValue, filteredBooks);
            }
        }


        // Handle report period selection
        document.getElementById('reportPeriod').addEventListener('change', (e) => {
            const monthSelector = document.getElementById('monthSelector');
            if (e.target.value === 'month') {
                monthSelector.style.display = 'block';
            } else {
                monthSelector.style.display = 'none';
            }
        });

        // Generate Report Button
        document.getElementById('generateReportBtn').addEventListener('click', openReportModal);

        // Filter books by date range
        function getFilteredBooks() {
            const period = document.getElementById('reportPeriod').value;
            
            if (period === 'all') {
                return books;
            } else if (period === 'month') {
                const selectedMonth = document.getElementById('reportMonth').value;
                return books.filter(b => b.month === selectedMonth);
            }
            return books;
        }

        // Generate detailed report with charts
        function generateReport() {
            const filteredBooks = getFilteredBooks();
            const reportContent = document.getElementById('reportContent');
            
            if (filteredBooks.length === 0) {
                reportContent.innerHTML = '<p style="text-align: center; padding: 2rem; color: var(--soft-brown);">No books found for the selected period.</p>';
                return;
            }

            const totalBooks = filteredBooks.length;
            const ratedBooks = filteredBooks.filter(b => b.rating).length;
            const avgRating = ratedBooks > 0
                ? (filteredBooks.reduce((sum, b) => sum + (b.rating || 0), 0) / ratedBooks).toFixed(2)
                : 'N/A';

            // Calculate stats
            const genreData = {};
            const formatData = { print: 0, digital: 0, audio: 0 };
            const monthData = {};
            const ratingDistribution = { '5': 0, '4-4.5': 0, '3-3.5': 0, '2-2.5': 0, '1-1.5': 0, '0.5': 0 };
            const tropeData = {};

            filteredBooks.forEach(b => {
                // Genre
                if (b.genre && b.genre !== 'Unknown') {
                    genreData[b.genre] = (genreData[b.genre] || 0) + 1;
                }
                
                // Format
                formatData[b.format] = (formatData[b.format] || 0) + 1;
                
                // Month
                monthData[b.month] = (monthData[b.month] || 0) + 1;
                
                // Rating distribution
                if (b.rating) {
                    if (b.rating === 5) ratingDistribution['5']++;
                    else if (b.rating >= 4) ratingDistribution['4-4.5']++;
                    else if (b.rating >= 3) ratingDistribution['3-3.5']++;
                    else if (b.rating >= 2) ratingDistribution['2-2.5']++;
                    else if (b.rating >= 1) ratingDistribution['1-1.5']++;
                    else ratingDistribution['0.5']++;
                }
                
                // Tropes
                if (b.tropes && Array.isArray(b.tropes)) {
                    b.tropes.forEach(trope => {
                        if (trope) tropeData[trope] = (tropeData[trope] || 0) + 1;
                    });
                }
            });

            // Top rated books
            const topBooks = [...filteredBooks]
                .filter(b => b.rating)
                .sort((a, b) => b.rating - a.rating)
                .slice(0, 10);

            reportContent.innerHTML = `
                <div style="background: linear-gradient(135deg, var(--accent-sage), var(--accent-terracotta)); color: white; padding: 1.5rem; border-radius: 8px; margin-bottom: 2rem; text-align: center;">
                    <h3 style="margin: 0 0 1rem 0; font-family: 'Libre Baskerville', serif;">Summary</h3>
                    <div style="display: flex; justify-content: space-around; flex-wrap: wrap; gap: 1rem;">
                        <div>
                            <div style="font-size: 2rem; font-weight: bold;">${totalBooks}</div>
                            <div style="font-size: 0.9rem; opacity: 0.9;">Books Read</div>
                        </div>
                        <div>
                            <div style="font-size: 2rem; font-weight: bold;">${avgRating}</div>
                            <div style="font-size: 0.9rem; opacity: 0.9;">Average Rating</div>
                        </div>
                        <div>
                            <div style="font-size: 2rem; font-weight: bold;">${ratedBooks}</div>
                            <div style="font-size: 0.9rem; opacity: 0.9;">Books Rated</div>
                        </div>
                    </div>
                </div>

                <div class="chart-grid">
                    <div class="chart-container">
                        <div class="chart-title">üìö Books by Genre</div>
                        <canvas id="genreChart"></canvas>
                    </div>
                    <div class="chart-container">
                        <div class="chart-title">üìñ Books by Format</div>
                        <canvas id="formatChart"></canvas>
                    </div>
                    <div class="chart-container">
                        <div class="chart-title">‚≠ê Rating Distribution</div>
                        <canvas id="ratingChart"></canvas>
                    </div>
                    <div class="chart-container">
                        <div class="chart-title">üìÖ Books by Month</div>
                        <canvas id="monthChart"></canvas>
                    </div>
                </div>

                ${Object.keys(tropeData).length > 0 ? `
                    <div class="chart-container" style="margin-bottom: 2rem;">
                        <div class="chart-title">üíï Most Popular Tropes</div>
                        <canvas id="tropeChart"></canvas>
                    </div>
                ` : ''}

                <div class="top-books-list">
                    <h3 style="font-family: 'Libre Baskerville', serif; color: var(--dark-brown); margin-bottom: 1rem;">‚≠ê Top Rated Books</h3>
                    ${topBooks.map((book, i) => `
                        <div class="top-book-item">
                            <div>
                                <strong>${i + 1}. ${book.title}</strong>
                                <div style="font-size: 0.9rem; color: var(--soft-brown);">by ${book.author}</div>
                            </div>
                            <div class="rating-stars">${displayStars(book.rating)}</div>
                        </div>
                    `).join('')}
                </div>

                <div style="text-align: center; margin-top: 2rem;">
                    <button type="button" onclick="closeReportModal()" style="padding: 0.75rem 2rem; background: var(--accent-sage); color: white; border: none; border-radius: 6px; cursor: pointer; font-weight: 600; font-size: 1rem;">
                        Close Report
                    </button>
                </div>
            `;

            // Render charts after a brief delay to ensure canvas elements are in DOM
            setTimeout(() => {
                renderCharts(genreData, formatData, ratingDistribution, monthData, tropeData);
            }, 100);
        }

        function renderCharts(genreData, formatData, ratingDistribution, monthData, tropeData) {
            const chartColors = [
                'rgba(139, 165, 153, 0.8)',
                'rgba(193, 126, 106, 0.8)',
                'rgba(139, 165, 153, 0.6)',
                'rgba(193, 126, 106, 0.6)',
                'rgba(139, 165, 153, 0.4)',
                'rgba(193, 126, 106, 0.4)'
            ];

            // Genre Chart
            if (Object.keys(genreData).length > 0) {
                const genreTotal = Object.values(genreData).reduce((a, b) => a + b, 0);
                new Chart(document.getElementById('genreChart'), {
                    type: 'pie',
                    data: {
                        labels: Object.keys(genreData),
                        datasets: [{
                            data: Object.values(genreData),
                            backgroundColor: chartColors
                        }]
                    },
                    options: {
                        responsive: true,
                        plugins: {
                            legend: { position: 'bottom' },
                            tooltip: {
                                callbacks: {
                                    label: function(context) {
                                        const label = context.label || '';
                                        const value = context.parsed || 0;
                                        const percentage = ((value / genreTotal) * 100).toFixed(1);
                                        return `${label}: ${value} (${percentage}%)`;
                                    }
                                }
                            }
                        }
                    }
                });
            }

            // Format Chart
            const formatTotal = formatData.print + formatData.digital + formatData.audio;
            new Chart(document.getElementById('formatChart'), {
                type: 'doughnut',
                data: {
                    labels: ['Print', 'Digital', 'Audio'],
                    datasets: [{
                        data: [formatData.print, formatData.digital, formatData.audio],
                        backgroundColor: chartColors.slice(0, 3)
                    }]
                },
                options: {
                    responsive: true,
                    plugins: {
                        legend: { position: 'bottom' },
                        tooltip: {
                            callbacks: {
                                label: function(context) {
                                    const label = context.label || '';
                                    const value = context.parsed || 0;
                                    const percentage = ((value / formatTotal) * 100).toFixed(1);
                                    return `${label}: ${value} (${percentage}%)`;
                                }
                            }
                        }
                    }
                }
            });

            // Rating Distribution Chart
            new Chart(document.getElementById('ratingChart'), {
                type: 'bar',
                data: {
                    labels: ['5 ‚≠ê', '4-4.5 ‚≠ê', '3-3.5 ‚≠ê', '2-2.5 ‚≠ê', '1-1.5 ‚≠ê', '0.5 ‚≠ê'],
                    datasets: [{
                        label: 'Number of Books',
                        data: Object.values(ratingDistribution),
                        backgroundColor: 'rgba(139, 165, 153, 0.8)'
                    }]
                },
                options: {
                    responsive: true,
                    plugins: {
                        legend: { display: false }
                    },
                    scales: {
                        y: { beginAtZero: true, ticks: { stepSize: 1 } }
                    }
                }
            });

            // Month Chart
            const monthOrder = ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December'];
            const orderedMonthData = monthOrder.map(m => monthData[m] || 0);
            
            new Chart(document.getElementById('monthChart'), {
                type: 'bar',
                data: {
                    labels: monthOrder,
                    datasets: [{
                        label: 'Books Read',
                        data: orderedMonthData,
                        backgroundColor: 'rgba(193, 126, 106, 0.8)'
                    }]
                },
                options: {
                    responsive: true,
                    plugins: {
                        legend: { display: false }
                    },
                    scales: {
                        y: { beginAtZero: true, ticks: { stepSize: 1 } }
                    }
                }
            });

            // Trope Chart
            if (Object.keys(tropeData).length > 0) {
                const sortedTropes = Object.entries(tropeData)
                    .sort((a, b) => b[1] - a[1])
                    .slice(0, 10);
                
                new Chart(document.getElementById('tropeChart'), {
                    type: 'bar',
                    data: {
                        labels: sortedTropes.map(t => t[0]),
                        datasets: [{
                            label: 'Number of Books',
                            data: sortedTropes.map(t => t[1]),
                            backgroundColor: 'rgba(139, 165, 153, 0.8)'
                        }]
                    },
                    options: {
                        responsive: true,
                        indexAxis: 'y',
                        plugins: {
                            legend: { display: false }
                        },
                        scales: {
                            x: { beginAtZero: true, ticks: { stepSize: 1 } }
                        }
                    }
                });
            }
        }
    </script>
</body>
</html>
